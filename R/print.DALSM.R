## -----------------------------------
## Philippe LAMBERT (ULiege, Oct 2018
## Email:  p.lambert@uliege.be
## Web: http://www.statsoc.ulg.ac.be
## -----------------------------------
#' Print summary information on a \code{DALSM.object}
#'
#' @description
#' Print summary information on a \code{DALSM.object}.
#'
#' @usage \method{print}{DALSM}(x, digits.est=3,digits.edf=2,digits.tst=2,digits.Pvalue=3,...)
#'
#' @param x an object of class \code{\link{DALSM.object}}.
#' @param digits.est number of digits when reporting parameter estimates (default: 3).
#' @param digits.edf number of digits when reporting effective degrees of freedom (default: 2).
#' @param digits.tst number of digits when reporting test statistics (default: 2).
#' @param digits.Pvalue number of digits when reporting P-values (default: 3).
#' @param ... additional generic printing arguments.
#'
#' @details Provides summary measures on the estimation of the regression parameters and additive terms
#' in the location and dispersion submodels corresponding to a \code{\link{DALSM.object}} generated by \code{\link{DALSM}}.
#'
#' @return No returned value (just printed summary).
#'
#' @author Philippe Lambert \email{p.lambert@uliege.be}
#' @references Lambert, P. (2021). Fast Bayesian inference using Laplace approximations
#' in nonparametric double additive location-scale models with right- and
#' interval-censored data.
#' \emph{Computational Statistics and Data Analysis}, 161: 107250.
#' <doi:10.1016/j.csda.2021.107250>
#'
#' @examples
#' require(DALSM)
#' data(DALSM_IncomeData)
#' resp = DALSM_IncomeData[,1:2]
#' fit = DALSM(y=resp,
#'             formula1 = ~twoincomes+s(age)+s(eduyrs),
#'             formula2 = ~twoincomes+s(age)+s(eduyrs),
#'             data = DALSM_IncomeData)
#' print(fit)
#'
#' @seealso \code{\link{plot.DALSM}}, \code{\link{DALSM.object}}, \code{\link{DALSM}}.
#'
#' @export
#'
print.DALSM = function(x, digits.est=3,digits.edf=2,digits.tst=2,digits.Pvalue=3,...){
    eps.Pvalue = 10^(-digits.Pvalue)
    obj = x
    ##
    printMat = function(mat,cs.est=NULL,cs.tst=NULL,cs.edf=NULL,cs.Pval=NULL){
        clnms = colnames(mat)
        mat = data.frame(mat)
        colnames(mat) = clnms
        if (!is.null(cs.est)){
            idx = cs.est ## Columns with parameter estimates
            mat[,idx] = round(mat[,idx],digits.est)
        }
        if (!is.null(cs.edf)){
            idx = cs.edf ## Columns with EDF
            mat[,idx] = round(mat[,idx],digits.edf)
        }
        if (!is.null(cs.tst)){
            idx = cs.tst ## Columns with test stats
            mat[,idx] = round(mat[,idx],digits.tst)
        }
        if (!is.null(cs.Pval)){
            Signif = symnum(as.vector(mat[,ncol(mat)]), ## Signif stars
                            corr = FALSE, na = FALSE,
                            cutpoints = c(0, 0.001, 0.01, 0.05, 0.1, 1),
                            symbols = c("***", "**", "*", ".", " "))
            idx = cs.Pval ## Columns with Pvalues
            mat0 = mat[,idx]
            mat0 = round(mat[,idx],digits.Pvalue)
            idx0 =  (mat0 < eps.Pvalue)
            mat0 = format(mat0,scientific=FALSE)
            mat0[idx0] = paste("<",format(eps.Pvalue,scientific=FALSE),sep="")
            mat[,idx] = mat0
            mat = cbind(mat, format(as.vector(Signif))) ## Add stars
            colnames(mat)[ncol(mat)] = ""
        }
        print(mat)
    }
    ##
    cat("---------------------------------------------------------------\n")
    cat("                Double Additive Location-Scale Model \n")
    cat("---------------------------------------------------------------\n")
    if (obj$REML){
        cat("*** REML-type estimation ***\n")
    }
    cat("Fixed effects for Location:\n")
    printMat(obj$fixed.loc,cs.est=1:4,cs.tst=5,cs.Pval=6)
    ## print(round(obj$fixed.loc,3))
    J1 = obj$regr1$J
    if (J1 > 0){
        cat("\n",length(obj$ED1[,1])," additive term(s) in Location: Eff.dim / Test No effect\n",sep="")
        ##    cat("\n",length(obj$ED1[,1])," additive term(s) in Location: Eff.dim / Test No effect or Linearity\n",sep="")
        if (ncol(obj$ED1) > 3){
            printMat(obj$ED1[,1:5,drop=FALSE],cs.edf=1:3,cs.tst=4,cs.Pval=5)
            ## printMat(obj$ED1[,c(1,4,5,2,3),drop=FALSE],cs.edf=1:3,cs.tst=4,cs.Pval=5)
        } else {
            printMat(obj$ED1[,c(1,2,3),drop=FALSE],cs.edf=1,cs.tst=2,cs.Pval=3)
        }
    }
    cat("\nFixed effects for Dispersion:\n")
    printMat(obj$fixed.disp,cs.est=1:4,cs.tst=5,cs.Pval=6)
    J2 = obj$regr2$J
    if (J2 > 0){
        cat("\n",length(obj$ED2[,1])," additive term(s) in Dispersion: Eff.dim / Test No effect\n",sep="")
        ##    cat("\n",length(obj$ED2[,1])," additive term(s) in Dispersion: Eff.dim / Test No effect or Linearity\n",sep="")
        if (ncol(obj$ED2) > 3){
            printMat(obj$ED2[,1:5,drop=FALSE],cs.edf=1:3,cs.tst=4,cs.Pval=5)
            ## printMat(obj$ED2[,c(1,4,5,2,3),drop=FALSE],cs.edf=1:3,cs.tst=4,cs.Pval=5)
        } else {
            printMat(obj$ED2[,c(1,2,3),drop=FALSE],cs.edf=1,cs.tst=2,cs.Pval=3)
        }
    }
    ##
    cat("\n")
    if (J1 > 0) cat(obj$K1,"  B-splines per additive component in location\n",sep="")
    if (J2 > 0) cat(obj$K2,"  B-splines per additive component in dispersion\n",sep="")
    if (obj$Normality) cat("Normality assumed for the error density\n")
    else cat(obj$K.error,"  B-splines for the error density on (",round(obj$rmin,2),",",round(obj$rmax,2),")\n",sep="")
    cat("\nTotal weighted sample size:", obj$sw,"; Credible level for CI:",1-obj$alpha,"\n")
    cat("Uncensored data: ", obj$n.uncensored, " (", round(100*obj$n.uncensored/obj$sw,2)," percents)\n",sep="")
    cat("Interval Censored data: ",obj$n.IC, " (",round(100*sum(obj$n.IC)/obj$sw,2), " percents)\n",sep="")
    cat("Right censored data: ",obj$n.RC, " (",round(100*obj$n.RC/obj$sw,2)," percents)\n",sep="")
    cat("---------------------------------------------------------------\n")
    cat("logEvid:",round(obj$logEvid,2),
        "  Dev:",round(obj$dev,2),
        "  AIC:",round(obj$AIC,2),
        "  BIC:",round(obj$BIC,2),
        "\n")
    cat("Convergence status: ",obj$converged,"  --  Algorithms: NR-",obj$density.method," / ",obj$psi.method,"-",obj$lambda.method,"\n",sep="")
    cat("Elapsed time: ",round(obj$elapsed.time,2)," seconds  (",obj$iter," iterations)\n",sep="")
    cat("---------------------------------------------------------------\n")
}
