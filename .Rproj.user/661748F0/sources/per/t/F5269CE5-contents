## GOAL:
##  Evaluate the fitted additive terms and their se's on a given set of values <xx> in (0,1)
##  Compute the mean coverage of (1-alpha) confidence intervals at these values <xx>
##
## INPUT:
##  obj.fit: object generated by LocationScaleFit
##  xx: values in (0,1) where the fitted additive terms will be computed
##  true.loc: list with the true functions for the additive terms in location
##  true.disp: list with the true functions for the additive terms in dispersion
##  alpha: desired credible level when computing coverages
##
## OUTPUT:
##  x.loc:  a (nx x J1) matrix with the covariate values at which each of the J1 additive terms in location are computed
##  x.disp: a (nx x J2) matrix with the covariate values at which each of the J2 additive terms in dispersion are computed
##  J1: number of additive terms for location
##  JZ: number of additive terms for dispersion
##  f.loc: matrix with one additive term for location evaluated at <xx> in each of the J1 columns
##  se.loc: matrix with the se's of one additive term for location evaluated at <xx> in each of the J1 columns
##  f.disp: matrix with one additive term for dispersion evaluated at <xx> in each of the J2 columns
##  se.disp: matrix with the se's of one additive term for dispersion evaluated at <xx> in each of the J2 columns
##  coverage.loc: J1-vector with the coverage of point-wise (1-alpha)-confidence intervals
##                at <xx> averaged over these <xx> values in the (0,1) range
##  coverage.disp: J2-vector with the coverage of point-wise (1-alpha)-confidence intervals
##                 at <xx> averaged over these <xx> values in the (0,1) range
##
## ------------------------------------
## Philippe LAMBERT (ULiege, June 2019)
## Email:  p.lambert@uliege.be
## Web: http://www.statsoc.ulg.ac.be
## ------------------------------------
#' Fitted \code{DALSM} additive terms and effective coverage of their credible intervals
#'
#' Compute the fitted additive terms of a \code{DALSM} model on a regular grid and report the mean effective coverage of pointwise credible intervals
#' for these additive terms with respect to given reference functions (such as the 'true' additive terms used in a simulation study to generate the data)
#' @usage CoverageAdditiveTerms(obj.fit, nx=101,
#'                       true.loc=NULL, true.disp=NULL, ci.level=NULL,
#'                       silent=FALSE)
#'
#' @param obj.fit an object of class \code{\link{DALSM.object}}
#' @param nx (optional) grid size of covariate values where the additive terms are calculated (default: 101)
#' @param true.loc (optional) list of functions containing the 'true' additive terms for location
#' @param true.disp (optional) list of functions containing the 'true' additive terms for dispersion
#' @param ci.level (optional) level of credible intervals
#' @param silent logical indicating whether the computed corverages should be printed out (default: FALSE)
#'
#' @return It returns an invisible list containing:
#' \itemize{
#' \item{\code{J1} : \verb{ }}{number of additive terms in the location sub-model}
#' \item{\code{x.loc} : \verb{ }}{a \code{nx} by \code{J1} matrix containing a regular grid of \code{nx} covariate values where the corresponding additive term in location is evaluated}
#' \item{\code{f.loc} : \verb{ }}{a \code{nx} by \code{J2} matrix containing the \code{J2} fitted location additive terms evaluated at \code{x.loc}}
#' \item{\code{se.loc} : \verb{ }}{a \code{nx} by \code{J2} matrix containing the the pointwise standard errors of the fitted location additive terms evaluated at \code{x.loc}}
#' \item{\code{coverage.loc} : \verb{ }}{a vector of length length \code{J1} giving the average effective coverage of pointwise credible intervals for each of the additive terms for location}
#' \item{\code{J2} : \verb{ }}{number of additive terms in the dispersion sub-model}
#' \item{\code{x.disp} : \verb{ }}{a \code{nx} by \code{J2} matrix containing a regular grid of \code{nx} covariate values where the corresponding additive term in dispersion is evaluated}
#' \item{\code{f.disp} : \verb{ }}{a \code{nx} by \code{J2} matrix containing the \code{J2} fitted dispersion additive terms evaluated at \code{x.disp}}
#' \item{\code{se.disp} : \verb{ }}{a \code{nx} by \code{J2} matrix containing the pointwise standard errors of the fitted dispersion additive terms evaluated at \code{x.disp}}
#' \item{\code{coverage.disp} : \verb{ }}{a vector of length length \code{J2} giving the average effective coverage of pointwise credible intervals for each of the additive terms for dispersion}
#' }
#'
#' @export
#' @author Philippe Lambert \email{p.lambert@uliege.be}#'
#' @examples
CoverageAdditiveTerms = function(obj.fit,
                                 nx=101,
                                 true.loc=NULL,true.disp=NULL,
                                 ci.level=NULL,
                                 silent=FALSE){
  if (is.null(ci.level)) ci.level = obj.fit$ci.level
  alpha = 1-ci.level
  z.alpha = qnorm(1-.5*alpha)
  ##
  npar.tot = with(obj.fit,length(psi1)+length(psi2))
  E.error = with(obj.fit$derr, mean.dist) ## Mean of the current density estimate
  V.error = with(obj.fit$derr, var.dist) ## Variance of the current density estimate
  ## Some stats on censoring (exactly observed, RC, IC)
  perc.obs = round(100*obj.fit$derr$n.uncensored/obj.fit$n,1) ## Percentage exactly observed
  perc.IC = round(100*sum(obj.fit$derr$n.IC)/obj.fit$n,1) ## Percentage Interval Censored
  perc.RC = round(100*sum(1-obj.fit$derr$event)/obj.fit$n,1) ## Percentage Right Censored
  ## Stats on fitted additive terms
  Bx1 = with(obj.fit,regr1$Bx) ; Bx2 = with(obj.fit,regr2$Bx)
  pen.order.1 = with(obj.fit,regr1$pen.order) ; pen.order.2 = with(obj.fit,regr2$pen.order)
  knots.1 = with(obj.fit,regr1$knots.x) ; knots.2 = with(obj.fit,regr2$knots.x)
  nfixed1 = with(obj.fit,regr1$nfixed) ; nfixed2 = with(obj.fit,regr2$nfixed)
  K1 = with(obj.fit,regr1$K) ; K2 = with(obj.fit,regr2$K)
  J1 = with(obj.fit,regr1$J) ; J2 = with(obj.fit,regr2$J)
  psi1.cur = obj.fit$psi1 ; psi2.cur = obj.fit$psi2
  ## ... for location
  f.loc = se.loc = NULL
  if (J1 > 0){
    Cst1 = coverage.loc = rep(0,J1)
    temp = matrix(nrow=nx,ncol=J1) ; rownames(temp) = 1:nx
    x.loc = f.loc = se.loc = temp
    addloc.lab = obj.fit$regr1$additive.lab
    colnames(x.loc) = addloc.lab ## paste("x.loc.",1:J1,sep="")
    colnames(f.loc) = paste("f(",addloc.lab,")",sep="") ## paste("f.loc.",1:J1,sep="")
    colnames(se.loc) = paste("se.",addloc.lab,sep="") ## paste("se.loc.",1:J1,sep="")
    names(coverage.loc) = colnames(f.loc)
    for (j in 1:J1){
      xlow = min(knots.1[[j]]) ; xup = max(knots.1[[j]])
      xx = seq(xlow,xup,length=nx)
      x.loc[,j] = xx
      BB.1 = centeredBasis.gen(xx,knots.1[[j]],cm=Bx1[[j]]$cm,pen.order=pen.order.1)$B
      idx = nfixed1 + (j-1)*K1 + (1:K1)
      S.loc = obj.fit$Cov.psi1
      S11 = S.loc[idx,idx]
      ##
      f.loc[,j] = fj.hat = BB.1%*%psi1.cur[idx]
      se.loc[,j] = fj.se = sqrt(pmax(0,rowSums((BB.1%*%S11)*BB.1)))
      fj.min = fj.hat-z.alpha*fj.se ; fj.max = fj.hat+z.alpha*fj.se
      ## Global credible region (essai)
      omega = sqrt(pmax(0,rowSums(BB.1*(BB.1%*%S11)))) / sqrt(qchisq(1-alpha,K1))
      Theta.up = psi1.cur[idx] + S11 %*% t((1/omega)*(BB.1)) ## K1 x length(xx) matrix
      Theta.low = psi1.cur[idx] - S11 %*% t((1/omega)*(BB.1)) ## K1 x length(xx) matrix
      cred.low = colSums(Theta.low*t(BB.1))
      cred.up = colSums(Theta.up*t(BB.1))
      if (!is.null(true.loc)){
        Cst1[j] = integrate(true.loc[[j]],xlow,xup)$val
        true.loc.j = true.loc[[j]](xx)-Cst1[j]
        coverage.loc[j] = mean((true.loc.j > fj.min) * (true.loc.j < fj.max))
      }
    }
  }
  ## ... for dispersion
  f.disp = se.disp = NULL
  if (J2 > 0){
    Cst2 = coverage.disp = rep(0,J2)
    temp = matrix(nrow=nx,ncol=J2) ; rownames(temp) = 1:nx
    x.disp = f.disp = se.disp = temp
    adddisp.lab = obj.fit$regr2$additive.lab
    colnames(x.disp) = adddisp.lab ## paste("x.disp.",1:J2,sep="")
    colnames(f.disp) = paste("f(",adddisp.lab,")",sep="") ## paste("f.disp.",1:J2,sep="")
    colnames(se.disp) = paste("se.",adddisp.lab,sep="") ## paste("se.disp.",1:J2,sep="")
    names(coverage.disp) = colnames(f.disp)
    for (j in 1:J2){
      xlow = min(knots.2[[j]]) ; xup = max(knots.2[[j]])
      xx = seq(xlow,xup,length=nx)
      x.disp[,j] = xx
      BB.2 = centeredBasis.gen(xx,knots.2[[j]],cm=Bx2[[j]]$cm,pen.order=pen.order.2)$B
      idx = nfixed2 + (j-1)*K2 + (1:K2)
      S.disp = obj.fit$Cov.psi2
      S11 = S.disp[idx,idx]
      ##
      f.disp[,j] = fj.hat = BB.2%*%psi2.cur[idx]
      se.disp[,j] = fj.se = sqrt(pmax(0,rowSums((BB.2%*%S11)*BB.2)))
      fj.min = fj.hat-z.alpha*fj.se ; fj.max = fj.hat+z.alpha*fj.se
      ## Global credible region (essai)
      omega = sqrt(pmax(0,rowSums(BB.2*(BB.2%*%S11)))) / sqrt(qchisq(1-alpha,K1))
      Theta.up = psi2.cur[idx] + S11 %*% t((1/omega)*(BB.2)) ## K1 x length(xx) matrix
      Theta.low = psi2.cur[idx] - S11 %*% t((1/omega)*(BB.2)) ## K1 x length(xx) matrix
      cred.low = colSums(Theta.low*t(BB.2))
      cred.up = colSums(Theta.up*t(BB.2))
      if (!is.null(true.disp)){
        Cst2[j] = integrate(true.disp[[j]],xlow,xup)$val
        true.disp.j = true.disp[[j]](xx)-Cst2[j]
        coverage.disp[j] = mean((true.disp.j > fj.min) * (true.disp.j < fj.max))
      }
    }
  }
  ## Return observed coverages if the true additive terms are known
  ans = list(J1=J1, ## Number of additive terms for location
             x.loc=x.loc, ## Additive terms in loc at <x.loc>
             f.loc=f.loc, se.loc=se.loc, ## Fitted location additive terms and their s.e. at <x.loc>
             J2=J2, ## Number of additive terms for dispersion
             x.disp=x.disp, ## Additive terms in disp evaluated at <x.disp>
             f.disp=f.disp, se.disp=se.disp) ## Fitted dispersion additive terms and their s.e. at <x.disp>
  ans$coverage.loc = ans$coverage.disp = NULL
  if (!is.null(true.loc)&(J1>0)) ans$coverage.loc = coverage.loc
  if (!is.null(true.disp)&(J2>0)) ans$coverage.disp = coverage.disp
  if (!is.null(ans$coverage.loc) | !is.null(ans$coverage.disp)){
    if (!silent){
      cat("Observed coverages for additive terms (with nominal coverage ",1-alpha,")\n",sep="")
      print(lapply(ans[c("coverage.loc","coverage.disp")], function(x) round(x,3)))
    }
  }
  return(invisible(ans))
}
