install.packages("roxygen2")
library("roxygen2")
usethis::use_package("MASS")
?usethis
devtools::document()
devtools::document()
devtools::document()
source('~/Myfiles/LaplacePsplines/DALSM/R/DALSM.R', echo=TRUE)
library(DALSM)
library(DALSM)
library(DALSM)
library(DALSM)
library(DALSM)
object.size(fit)
library(DALSM)
library(DALSM)
library(DALSM)
library(DALSM)
library(DALSM)
library(DALSM)
library(DALSM)
library(DALSM)
library(DALSM)
library(DALSM)
library(DALSM)
library(DALSM)
library(DALSM)
library(DALSM)
library(DALSM)
library(DALSM)
library(DALSM)
library(DALSM)
library(DALSM)
?DALSM
library(DALSM)
?predict.lm
predict.lm
predict.gam
mgcv::predict.gam
args(mgcv)
args(gam)
args(mgcv::gam)
mgcv::gam
?mgcv::gam
x1=runif(20)
x2=runif(20)
y = sin(x1)+1/(1+x2^2)+rnorm(20)
x1=runif(200)
x2=runif(200)
y = sin(x1)+1/(1+x2^2)+rnorm(200)
obj = mgcv::gam(y~s(x1)+s(x2))
obj$terms
mgcv::predict.gam(obj)
args(mgcv::predict.gam)
mgcv::predict.gam(obj,data.frame(x1=.4,x2=.8))
mgcv::predict.gam(obj,data.frame(x1=c(.4,.2),x2=c(.3,.8)))
mgcv::predict.gam(obj,data.frame(x1=c(.4,.2))
)
plot(obj)
obj = mgcv::gam(y~s(x1)+s(x2))
obj
plot(x1,y)
y = sin(x1)+1/(1+x2^2)+rnorm(200,0,.1)
plot(x1,y)
y = sin(x1/2/pi)+1/(1+x2^2)+rnorm(200,0,.1)
plot(x1,y)
plot(x1,y)
y = sin(x1*2*pi)+1/(1+x2^2)+rnorm(200,0,.1)
plot(x1,y)
obj = mgcv::gam(y~s(x1)+s(x2))
obj
plot(obj)
obj
names(obj)
obj$coefficients
obj$terms
obj$linear.predictors
obj$hat
str(obj$hat)
names(obj)
obj$smooth
names(obj$smooth)
names(obj$smooth)
str(obj$smooth)
is.missing(NULL)
missing(NULL)
?missing
f
f = function(x,a) x+a
f(3)
f = function(x,a) ifelse(missing(a),x,x+a)
f(3)
f(3,3)
a=2
f(3)
?optim
?quantile
library(DALSM)
predict.DALSM
library(DALSM)
library(DALSM)
library(DALSM)
library(DALSM)
library(DALSM)
contour.plot
contourLines
library(DALSM)
args(pdeict.lm)
args(predict.lm)
predict.lm
x = runif(200) ; y=.3+.5*x + rnorm(200)
obj = lm(y~x)
model.matrix(obj)
library(mgcv)
obj=gam(formula= y ~ x)
obj=gam(formula= y ~ s(x)
)
model.matrix(obj)
names(obj)
obj$pred.formula
obj$pterms
obj$terms
obj$coef
obj$sig2
obj$cmX
library(DALSM)
library(DALSM)
?DALSM
library(DALSM)
data("IncomePerPerson")
ls()
data[1:10,]
x
y
library(DALSM)
?CoverageAdditiveTerms
library(DALSM)
?CoverageAdditiveTerms
library(DALSM)
?gamls
?mgcv::gamls
mgcv::gamls
?mgcv::gam
library(DALSM)
?CoverageAdditiveTerms
library(DALSM)
library(DALSM)
?CoverageAdditiveTerms
library(DALSM)
?CoverageAdditiveTerms
library(DALSM)
?CoverageAdditiveTerms
library(DALSM)
?CoverageAdditiveTerms
library(DALSM)
?CoverageAdditiveTerms
library(DALSM)
?CoverageAdditiveTerms
prior_mu = function(mu) dnorm(mu,mean=3000,sd=600/1.96,log=TRUE)
prior_phi =  function(phi) dunif(phi,min=0,max=10,log=TRUE)
proba = function(theta)
{
borne <- c(0,1200,1500,1800,2300,2700,3300,4000,4900,6000)
kappa = 1/theta[2]
lambda= 1/(theta[1]*theta[2])
for(i in 1: (length(borne))) prob[i]=pgamma(borne[i+1],kappa,lambda)-pgamma(borne[i],kappa,lambda)
prob[i]= 1-pgamma(borne[i],kappa,lambda)
prob
}
lpost = function(theta,freq)
{
dmultinom(freq,size=NULL,proba(theta),log=TRUE) + prior_mu(theta[1])+prior_phi(theta[2])
}
freq1 <- c(25,69,65,106,80,106,136,94,76,46)
#Laplace
g=function(theta) -lpost(theta,freq1)
obj = nlm(g,c(2050,0.2),hessian=T)
proba(c(2050,.2))
library(DALSM)
?DALSM
require(DALSM)
data(DALSM_IncomeData)
resp = DALSM_IncomeData[,1:2]
fit = DALSM(y=resp,
formula1 = ~twoincomes+s(age)+s(eduyrs),
formula2 = ~twoincomes+s(age)+s(eduyrs),
data = DALSM_IncomeData)
ans = CoverageAdditiveTerms(fit)
names(ans)
with(ans,plot(x.loc[,1],f.loc[,1],type="l"))
with(ans,head(x.loc))
with(ans,matplot(x.loc,f.loc,type="l"))
plto(fit)
plot(fit)
with(ans,matplot(x.loc,disp.loc,type="l"))
with(ans,matplot(x.loc,f.disp,type="l"))
library(DALSM)
require(DALSM)
data(DALSM_IncomeData)
resp = DALSM_IncomeData[,1:2]
fit = DALSM(y=resp,
formula1 = ~twoincomes+s(age)+s(eduyrs),
formula2 = ~twoincomes+s(age)+s(eduyrs),
data = DALSM_IncomeData)
ans = CoverageAdditiveTerms(fit)
fun1 = list(function(x) -.4*sqrt(x)*sin(1.2*pi*x), function(x) .6-.3/(x^2+.3)) ##, function(x) .4*x)
fun2 = list(function(x) -.15+.15*x+.25*x^2, function(x) 12*(x-.5)^3)
range(ans$x.loc[,1])
beta.true = c(1.6,.3,.75)   ## Location: Fixed covariate ## Values in 1st submission
## beta.true = c(1.6,.3,.1)   ## Location: Fixed covariate
## Covariates with linear effects on location
z1 = rbinom(n,1,.6) ; z2 = rnorm(n,0,1) ## sqrt(1/4))
Z1 = cbind(Intcpt=rep(1,n),z1=z1,z2=z2)
## True additive effects on location
fun1 = list(function(x) -.4*sqrt(x)*sin(1.2*pi*x), function(x) .6-.3/(x^2+.3)) ##, function(x) .4*x)
##
J1 = length(fun1)
Cst1 = rep(0,J1)
for (j in 1:J1) Cst1[j] = integrate(fun1[[j]],0,1)$val
##
## Covariates with functional effects on location
X1 = matrix(nrow=n,ncol=J1)
for (j in 1:J1) X1[,j] = sample(c(0,runif(n-2,0,1),1))
##
mu.x = c(Z1 %*% beta.true) ## Fixed effects
for (j in 1:J1) mu.x = mu.x + (fun1[[j]](X1[,j])-Cst1[j]) ## ... plus additive ones
## DISPERSION
## True regression parameters
delta.true = c(-.5,-.03,.01) ## Dispersion: Fixed covariate
## delta.true = c(-.5,-.2,.1) ## Dispersion: Fixed covariate
## delta.true = -.5
## Covariates with linear effects on dispersion
zd1 = rbinom(n,1,.6) ; zd2 = rnorm(n,0,1)  ## sqrt(1/4)) ## Share same binary covariate
Z2 = cbind(Intcpt=rep(1,n),zd1=zd1,zd2=zd2)
## Z2 = cbind(Intcpt=rep(1,n)) ##,zd1=zd1,zd2=zd2)
## True conditional dispersion
fun2 = list(function(x) -.15+.15*x+.25*x^2, function(x) 12*(x-.5)^3)
## fun2 = list(function(x) -x*sin(2*pi*x), function(x) -.4/(x+.3), function(x) x)
##
J2 = length(fun2)
Cst2 = rep(0,J2)
for (j in 1:J2) Cst2[j] = integrate(fun2[[j]],0,1)$val
##
## Covariates with functional effects on dispersion
X2 = matrix(nrow=n,ncol=J2)  ## <--------------  B A C K   to different covariates for location and dispersion !!!!
for (j in 1:J2) X2[,j]= sample(c(0,runif(n-2,0,1),1))
##
ldisp.x = c(Z2 %*% delta.true) ## Fixed effects
for (j in 1:J2) ldisp.x = ldisp.x + (fun2[[j]](X2[,j])-Cst2[j]) ## ... plus additive ones
##
sd.x = exp(ldisp.x) ## + .3*sin(2*pi*x)))
## True ERROR TERM
## Mixture density with mean 0 and sd = sqrt(.834)
w.1 = .8 ; mu.1 = -1 / 2.4163  ; sd.1 = 1.3 / 2.4163
w.2 = .2 ; mu.2 = 4 / 2.4163  ; sd.2 = 1.2*sd.1
## w.1 = .6 ; mu.1 = -.8 ; sd.1 = .5
## w.2 = .4 ; mu.2 = 1.2  ; sd.2 = .6
mean.mix = w.1*mu.1 + w.2*mu.2
var.mix = w.1*sd.1^2+w.2*sd.2^2 + (w.1*mu.1^2+w.2*mu.2^2-mean.mix^2)
derr = function(x) w.1*dnorm(x,mu.1,sd.1) + w.2*dnorm(x,mu.2,sd.2)
derr0 = function(x) sqrt(var.mix)*derr((x-mean.mix)*sqrt(var.mix))
perr = function(x) w.1*pnorm(x,mu.1,sd.1) + w.2*pnorm(x,mu.2,sd.2)
## gh = function(x){
##     w.1 = .8 ; mu.1 = -1 / x  ; sd.1 = 1.3 / x
##     w.2 = .2 ; mu.2 = 4 / x  ; sd.2 = 1.2*sd.1
##     mean.mix = w.1*mu.1 + w.2*mu.2
##     var.mix = w.1*sd.1^2+w.2*sd.2^2 + (w.1*mu.1^2+w.2*mu.2^2-mean.mix^2)
##     var.mix-1
## }
## Random generation of errors
temp1 = rnorm(n,mu.1,sd.1) ; temp2 = rnorm(n,mu.2,sd.2)
err = ifelse(runif(n)<w.1,temp1,temp2)
## hist(err,breaks=25)
## Standardize the errors
## err0 = (err-mean.mix) / sqrt(var.mix)
err0 = (err - mean(err)) / sd(err)
err0 = pmin(6,err0) ; err0 = pmax(-6,err0)
## Observed Response (possibly right censored)
resp.true = mu.x + sd.x * err0 ## True (uncensored) response
if (p.RC==0){
tcens = 0*resp.true + max(resp.true) + 1
} else {
## Tune the mean of the (c.min + exponentially distributed) right censoring times
##   to reach <p.RC> for the proportion of RC data
gc = function(mu){
y.star = pmax(0,resp.true-c.min) ## <c.min> is the minimal value of a RC time
lam = 1/abs(mu)
ans = (mean(exp(-lam*y.star)) - (1-p.RC))^2
return(ans)
}
## gc = function(mu){
##     lam = 1/abs(mu)
##     ans = (mean(exp(-lam*resp.true)) - (1-p.RC))^2
##     return(ans)
## }
temp = optim(mean(resp.true),gc,method="BFGS")
tcens.mean = abs(temp$par) ## Desired mean censoring time (after subtraction of c.min)
tcens = c.min + rexp(n,1/tcens.mean) ## Generate candidates for RC times
}
event = 0 + (tcens > resp.true) ## Event indicator
resp = ifelse(event==1,resp.true,tcens) ## Report response (possibly right censored)
## Introduce Interval Censoring
## p.IC = 0 ##.1 ##.5 ## Prob to be IC for a subject having the event ## <------------  HERE HERE
## width.IC = sd.IC*sd.x ## .5*sd(resp.true) ##2 ## Length of an IC interval ## PHL
width.IC = sd.IC*mean(sd.x) ## .5*sd(resp.true) ##2 ## Length of an IC interval
pos.IC = runif(n,0,1) ## Position of the event time withing the IC interval of width <width.IC>
idx.IC = sample(which(event==1),size=min(sum(event),round(n*p.IC)))
is.IC = rep(0,n) ; is.IC[idx.IC] = 1
## is.IC = (event==1) & (rbinom(n,1,p.IC)==1) ## IC indicator
##
ymin = min(resp.true) ; ymax = max(resp.true)
## ylow = pmax(ymin, ifelse(!is.IC, resp, resp-pos.IC*width.IC))
## yup = pmin(ymax, ifelse(!is.IC, resp, resp+(1-pos.IC)*width.IC))
ylow = ifelse(!is.IC, resp, resp-pos.IC*width.IC) ## PHL
yup = ifelse(!is.IC, resp, resp+(1-pos.IC)*width.IC) ## PHL
yup[event==0] = Inf ## RC data
resp.mat = cbind(ylow,yup)
#### MODEL and INFERENCE ####
#############################
## Generic knots for additive terms on (0,1)
knots.x = seq(0,1,length=9) ; pen.order.x = 2
## ## LOCATION
## ## Generate global design matrix for fixed design matrix <Z> and design mat for additive terms with cov in <X>
## design.loc = GlobalDesignMat(Z=Z1,X=X1,knots.x=knots.x,pen.order=pen.order.x,lab.fixed="beta",lab.additive="1")
## ## DISPERSION
## ## Generate global design matrix for fixed design matrix <Z> and design mat for additive terms with cov in <X>
## design.disp = GlobalDesignMat(Z=Z2,X=X2,knots.x=knots.x,pen.order=pen.order.x,lab.fixed="delta",lab.additive="2")
## Model fitting
if (Normality) cat("!! Normality for the error term assumed !!\n")
rfun = function(mat){
idx = which(!is.finite(mat[,2]))
mat[idx,2] = mat[idx,1]
ans = runif(nrow(mat),mat[,1],mat[,2])
return(ans)
}
f1
f1 = expression(~twoincomes+s(age)+s(eduyrs))
f1
library(DALSM)
?CoverageAdditiveTerms
library(DALSM)
?CoverageAdditiveTerms
library(DALSM)
?CoverageAdditiveTerms
library(DALSM)
?CoverageAdditiveTerms
library(DALSM)
library(DALSM)
?CoverageAdditiveTerms
library(DALSM)
?s
library(help=DALSM)
diag(0,5)
?Pcal.fun
?Pcal.fun
Pcal.fun
?DALSM::Pcal.fun
library(DALSM)
?Pcal.fun
library(DALSM)
?Pcal.fun
library(DALSM)
a
a$essai=2
library(DALSM)
?DALSM
require(DALSM)
data(DALSM_IncomeData)
resp = DALSM_IncomeData[,1:2]
fit = DALSM(y=resp,
formula1 = ~twoincomes+s(age)+s(eduyrs),
formula2 = ~twoincomes+s(age)+s(eduyrs),
data = DALSM_IncomeData)
debug(DALSM)
fit = DALSM(y=resp,
formula1 = ~twoincomes+s(age)+s(eduyrs),
formula2 = ~twoincomes+s(age)+s(eduyrs),
data = DALSM_IncomeData)
fit = DALSM(y=resp,
formula1 = ~twoincomes+s(age)+s(eduyrs),
formula2 = ~twoincomes+s(age)+s(eduyrs),
data = DALSM_IncomeData)
print(fit1d0)
fit1d.0
print(fit1d.0)
curve(fit1d$derr$ddist,-6,6)
curve(fit1d$ddist,-6,6)
curve(fit1d$ddist(x),-6,6)
debug(ff)
length(mu.cur)
range(mu.cur)
Q
fit = DALSM(y=resp,
formula1 = ~twoincomes+s(age)+s(eduyrs),
formula2 = ~twoincomes+s(age)+s(eduyrs),
data = DALSM_IncomeData)
debug(ff)
phi.cur
length(phi.cur)
length(event)
length(sd.cur)
dim(dB1)
dim(res[,1])
length(res[,1])
dim(res[,1])
bele=D1Bsplines(res[,1], fit1d$knots)
fit1d$knots
fit1d
fit = DALSM(y=resp,
formula1 = ~twoincomes+s(age)+s(eduyrs),
formula2 = ~twoincomes+s(age)+s(eduyrs),
data = DALSM_IncomeData)
debug(ff)
fit1d$knots
names(fit1d)
library(DALSM)
a = list(NULL)
a
a$b=c(2,3)
a
a = list()
a
a$b=c(2,3)
a
d = list(X=matrix(1:4,ncol=2),g=function(x)sin(x)X)
d = list(X=matrix(1:4,ncol=2),g=function(x)sin(x))
d
a
c(a,d)
library(DALSM)
?DALSM
require(DALSM)
data(DALSM_IncomeData)
resp = DALSM_IncomeData[,1:2]
fit = DALSM(y=resp,
formula1 = ~twoincomes+s(age)+s(eduyrs),
formula2 = ~twoincomes+s(age)+s(eduyrs),
data = DALSM_IncomeData)
fit
plot(fit)
data = DALSM_IncomeData)fit = DALSM(y=resp,
formula1 = ~twoincomes+s(age)+s(eduyrs),
formula2 = ~twoincomes+age+eduyrs,
data = DALSM_IncomeData)
fit = DALSM(y=resp,
formula1 = ~twoincomes+s(age)+s(eduyrs),
formula2 = ~twoincomes+age+eduyrs,
data = DALSM_IncomeData)
fit = DALSM(y=resp, formula1 = ~twoincomes+s(age)+s(eduyrs), formula2 = ~twoincomes+age+eduyrs, data = DALSM_IncomeData)
fit
plot(fit)
library(DALSM)
library(hlpe=DALSM)
library(help=DALSM)
?densityGivenMeanVariance
library(help=DALSM)
library(DALSM)
install.packages(plyr)
install.packages("plyr")
library(DALSM)
library(help=DALSM)
?densityGivenMeanVariance
